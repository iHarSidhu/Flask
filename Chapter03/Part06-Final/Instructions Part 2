Chapter 3 – Part 6: Editing and Deleting Posts (Delete)

# Delete Route — /post/<int:post_id>/delete
      @app.route('/post/<int:post_id>/delete', methods=['POST'])
      def deletePost(post_id):
          post = Post.query.get_or_404(post_id)
          db.session.delete(post)
          db.session.commit()
          return redirect(url_for('showPosts'))

Why delete is POST only
Delete is a destructive action.
If it were GET, a simple link click could delete data, and even browsers/robots could trigger it accidentally.

POST-only is safer.

# Add Edit/Delete controls in posts.html
      <a href="{{ url_for('editPost', post_id=post.id) }}">Edit</a>
      
      <form action="{{ url_for('deletePost', post_id=post.id) }}" method="post" style="display:inline;">
          <button type="submit">Delete</button>
      </form>

What this means
    Edit is safe as a GET link
    Delete uses a POST form submission
    This is proper web practice.

# Two Important Professional Fixes
Fix 1: CSRF token for Delete form
Because we are using Flask-WTF and CSRF protection, delete POST should also include a CSRF token.
Right now delete form has no hidden token. It might still work depending on setup, but the correct pattern is:

Option A (quick + clean): disable CSRF for delete route (not recommended long-term)
Not preferred.

Option B (recommended): create a tiny DeleteForm
In forms.py:
      from flask_wtf import FlaskForm
      from wtforms import SubmitField
      
      class DeleteForm(FlaskForm):
          submit = SubmitField('Delete')

In route when rendering posts, pass delete_form=DeleteForm().
Then in template:
      <form action="{{ url_for('deletePost', post_id=post.id) }}" method="post" style="display:inline;">
          {{ delete_form.hidden_tag() }}
          {{ delete_form.submit() }}
      </form>

That makes delete fully CSRF-safe.

Fix 2: Add a confirmation prompt
In template:
      <button type="submit" onclick="return confirm('Delete this post?')">Delete</button>

